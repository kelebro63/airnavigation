package com.example.airnavigate.Dao;

import com.example.airnavigate.Dao.DaoSession;
import de.greenrobot.dao.DaoException;

// THIS CODE IS GENERATED BY greenDAO, EDIT ONLY INSIDE THE "KEEP"-SECTIONS

// KEEP INCLUDES - put your custom includes here
// KEEP INCLUDES END
/**
 * Entity mapped to table "VOTING".
 */
public class Voting {

    private Integer id;
    private String subject;
    private String voteDate;
    private Integer voteCount;
    private Integer forCount;
    private Integer againstCount;
    private Integer abstainCount;
    private Integer absentCount;
    private String resultType;
    private Boolean result;
    private long votingResultId;

    /** Used to resolve relations */
    private transient DaoSession daoSession;

    /** Used for active entity operations. */
    private transient VotingDao myDao;

    private VotingResult votingResult;
    private Long votingResult__resolvedKey;


    // KEEP FIELDS - put your custom fields here
    // KEEP FIELDS END

    public Voting() {
    }

    public Voting(Integer id, String subject, String voteDate, Integer voteCount, Integer forCount, Integer againstCount, Integer abstainCount, Integer absentCount, String resultType, Boolean result, long votingResultId) {
        this.id = id;
        this.subject = subject;
        this.voteDate = voteDate;
        this.voteCount = voteCount;
        this.forCount = forCount;
        this.againstCount = againstCount;
        this.abstainCount = abstainCount;
        this.absentCount = absentCount;
        this.resultType = resultType;
        this.result = result;
        this.votingResultId = votingResultId;
    }

    /** called by internal mechanisms, do not call yourself. */
    public void __setDaoSession(DaoSession daoSession) {
        this.daoSession = daoSession;
        myDao = daoSession != null ? daoSession.getVotingDao() : null;
    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getSubject() {
        return subject;
    }

    public void setSubject(String subject) {
        this.subject = subject;
    }

    public String getVoteDate() {
        return voteDate;
    }

    public void setVoteDate(String voteDate) {
        this.voteDate = voteDate;
    }

    public Integer getVoteCount() {
        return voteCount;
    }

    public void setVoteCount(Integer voteCount) {
        this.voteCount = voteCount;
    }

    public Integer getForCount() {
        return forCount;
    }

    public void setForCount(Integer forCount) {
        this.forCount = forCount;
    }

    public Integer getAgainstCount() {
        return againstCount;
    }

    public void setAgainstCount(Integer againstCount) {
        this.againstCount = againstCount;
    }

    public Integer getAbstainCount() {
        return abstainCount;
    }

    public void setAbstainCount(Integer abstainCount) {
        this.abstainCount = abstainCount;
    }

    public Integer getAbsentCount() {
        return absentCount;
    }

    public void setAbsentCount(Integer absentCount) {
        this.absentCount = absentCount;
    }

    public String getResultType() {
        return resultType;
    }

    public void setResultType(String resultType) {
        this.resultType = resultType;
    }

    public Boolean getResult() {
        return result;
    }

    public void setResult(Boolean result) {
        this.result = result;
    }

    public long getVotingResultId() {
        return votingResultId;
    }

    public void setVotingResultId(long votingResultId) {
        this.votingResultId = votingResultId;
    }

    /** To-one relationship, resolved on first access. */
    public VotingResult getVotingResult() {
        long __key = this.votingResultId;
        if (votingResult__resolvedKey == null || !votingResult__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            VotingResultDao targetDao = daoSession.getVotingResultDao();
            VotingResult votingResultNew = targetDao.load(__key);
            synchronized (this) {
                votingResult = votingResultNew;
            	votingResult__resolvedKey = __key;
            }
        }
        return votingResult;
    }

    public void setVotingResult(VotingResult votingResult) {
        if (votingResult == null) {
            throw new DaoException("To-one property 'votingResultId' has not-null constraint; cannot set to-one to null");
        }
        synchronized (this) {
            this.votingResult = votingResult;
            votingResultId = votingResult.getId();
            votingResult__resolvedKey = votingResultId;
        }
    }

    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
    public void delete() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.delete(this);
    }

    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
    public void update() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.update(this);
    }

    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
    public void refresh() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.refresh(this);
    }

    // KEEP METHODS - put your custom methods here
    // KEEP METHODS END

}
